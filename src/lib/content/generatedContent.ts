// Auto-generated content imports - do not edit manually
// Generated by scripts/generateContentImports.ts
// This file provides type-safe access to all blog content at build time

import type { SerializedPost } from '@/types/post'

import css_fix_social_icon_flicker_on_theme_toggle_md_content from '@/content/blog/css/fix-social-icon-flicker-on-theme-toggle.md?raw'
import inkdrop_how_i_learn_new_framework_md_content from '@/content/blog/inkdrop/how-i-learn-new-framework.md?raw'
import inkdrop_notes_in_service_of_doing_choosing_inkdrop_md_content from '@/content/blog/inkdrop/notes-in-service-of-doing-choosing-inkdrop.md?raw'
import neovim_native_lsp_setup_in_neovim_0_11__on_macos_md_content from '@/content/blog/neovim/native-lsp-setup-in-neovim-0.11+-on-macos.md?raw'
import wezterm_wezterm_terminal_setup_md_content from '@/content/blog/wezterm/wezterm-terminal-setup.md?raw'

// Raw markdown content accessible by file path
export const contentModules = {
  '@/content/blog/css/fix-social-icon-flicker-on-theme-toggle.md': css_fix_social_icon_flicker_on_theme_toggle_md_content,
  '@/content/blog/inkdrop/how-i-learn-new-framework.md': inkdrop_how_i_learn_new_framework_md_content,
  '@/content/blog/inkdrop/notes-in-service-of-doing-choosing-inkdrop.md': inkdrop_notes_in_service_of_doing_choosing_inkdrop_md_content,
  '@/content/blog/neovim/native-lsp-setup-in-neovim-0.11+-on-macos.md': neovim_native_lsp_setup_in_neovim_0_11__on_macos_md_content,
  '@/content/blog/wezterm/wezterm-terminal-setup.md': wezterm_wezterm_terminal_setup_md_content
}

// Processed blog posts with metadata and content
// Note: dates are serialized as ISO strings and must be converted to Date objects
export const processedPosts: SerializedPost[] = [
  {
    "title": "Why transition: all Is Risky (CSS Transition Pitfall)",
    "date": "2025-12-04T00:00:00.000Z",
    "description": "It wasn’t catastrophic but once you see it, you can’t unsee it. On slower machines or reduced motion environments, it became even more noticeable.",
    "tags": [
      "css",
      "bugs",
      "debugging",
      "fix"
    ],
    "slug": "fix-social-icon-flicker-on-theme-toggle",
    "topic": "css",
    "content": "\n# The Symptom\n\nWhile working on a dark mode toggle, I noticed something subtle but irritating.\nThe social icons would briefly flash before snapping into their correct color\nwhile the rest of the UI transitioned smoothly. At first glance, it looked like\na hydration issue, a delayed theme state update, or even an SVG rendering problem.\nBut after digging deeper, it turned out to be something much simpler.\n\n## The Root Cause\n\nSurprisingly, the issue wasn’t React, the theme toggle, or Vite. I spent way too\nlong checking React DevTools before I thought to look at the CSS. The culprit was\na single line of CSS:\n\n```css\ntransition: all;\n```\n\nBecause the icons used `filter` for coloring, specifying `transition: all` caused\nthe browser to animate every possible property. During the theme change, some of\nthese properties temporarily passed through invalid or intermediate visual states,\nwhich is exactly what caused the flicker.\n\n## The FIX\n\nThe solution was simple once I understood the problem. Instead of transitioning\nevery property, I limited the transition to exactly what I needed. Updating the\nCSS for the social icons to:\n\n```css\n.socials__icon {\n  /* Transition only filter to prevent unwanted flickers */\n  transition: filter var(--transition-duration-normal);\n  filter: drop-shadow(0 0 0 transparent);\n}\n```\n\nOnce I changed:\n\n```css\ntransition: all;\n```\n\nto:\n\n```css\ntransition: filter;\n```\n\nThe flicker disappeared entirely.\n\nNo JavaScript changes.\nNo theme logic changes.\nJust a scoped transition.\n\n# A Lesson in transition: all\n\n> `transition: all` is convenient — but often dangerous.\n\nThis experience reinforced an easy-to-forget rule. Animating all properties can\ncause unintended visual glitches during state changes, trigger strange\nintermediate render states, and make bugs harder to reason about. Explicitly\ntargeting only the properties that need animation is safer, more predictable, and\nprevents subtle UI regressions.\n\nThis small bug reminded me that some of the most valuable lessons come from tiny,\nalmost invisible issues. It wasn’t about performance, complex architecture, or\nadvanced animations. It was about paying attention to the details. I'd been\ncareless with `transition: all` because it was quick and seemed harmless, but\nthat one line caused a subtle visual glitch that took way too long to track down.\n\n## Key Takeaway\n\nBe intentional with transitions. Target only the properties you need to animate\nand avoid `transition: all` unless you really mean it. This prevents subtle\nvisual glitches and makes your UI more predictable.\n",
    "readingTime": 2
  },
  {
    "title": "How I Learn New Framework",
    "date": "2025-12-22T00:00:00.000Z",
    "description": "As a full time Solutions Consultant and self-taught developer, one of the hardest challenges is keeping pace with the ever-changing world of web development while still grounding myself in the fundamentals.",
    "tags": [
      "learning",
      "productivity",
      "personal growth",
      "developer journey"
    ],
    "slug": "how-i-learn-new-framework",
    "topic": "inkdrop",
    "content": "\n## What Drives Me\n\nEvery time a new framework emerges, it shines like a freshly polished tool in a crowded workshop. Its simplicity, elegance, and promise of quick mastery can easily lure beginners like me. I’ve felt that pull, the temptation to dive in headfirst simply because it looks easy to use.\n\nBut I’ve learned to pause. Instead of chasing novelty for its own sake, I ask myself: What tangible benefits does this bring? Which problems does it truly solve compared to my current workflow? Why choose this path over another? And—most importantly—when does it make sense for the project I’m building?\n\nThis approach turns learning from a superficial sprint into a deliberate, meaningful journey. It’s less about following trends and more about understanding purpose.\n\n## Learning the Patterns\n\nWhen I dive into a new framework, one of the first things I notice is the syntax—the patterns, the way pieces fit together. As a beginner, logic often feels like a foreign language. I’ve learned that it’s okay to feel lost at the start. That confusion, frustrating as it can be, is also the part that makes the journey thrilling: the puzzle of picking up tiny fragments of information and slowly connecting them into something meaningful.\n\nI’ve accepted that there’s no shortcut. When I get stuck, I turn to ChatGPT, asking it to explain things in beginner-friendly ways, often with analogies I can relate to. I don’t shy away from the “dumb” questions: What is a React hook? Why do some YouTubers use Zustand? Can I skip React hooks and jump straight to Zustand?\n\nSure, my questions reveal my confusion—but over days, the pieces start to click. I begin to see why Zustand is not a replacement but an essential tool, and why Zustand becomes valuable when managing complex state, like comments and reactions on my blog. Simple tasks like theming still suit useState, but when coordination grows tricky, a tool like Zustand turns chaos into clarity. Slowly, I begin to understand what “complicated” really means in the context of code—and why learning the basics matters before chasing the next shiny tool.\n\n## We Humans Are Not Perfect\n\nAnother crucial part of my learning journey is embracing imperfection. I’ve learned that it’s not enough to simply jot down solutions—I need to capture the confusion, the “why” behind each step, and the thoughts that swirl around my head as I try to make sense of it all.\n\nThis is where [Inkdrop](https://www.inkdrop.app/) comes in. It’s a note-taking app that doesn’t distract me, doesn’t pull me away from the flow of learning. Instead, it gives me focus. It allows me to write freely, to explore my thoughts, and to slowly connect the dots at my own pace. Less friction, more space for curiosity—and more time to truly understand.\n\n## The Journey Matters More Than the Tools\n\nAt the end of the day, it’s not about the newest framework, the slickest library, or the trendiest tool. It’s about the process—the curiosity, the mistakes, the small victories, and the slow, steady understanding that comes from embracing the unknown.\n\nAs a full time Solutions Consultant and self-taught developer, every confusion is a teacher, every “why” is a doorway, and every note I take is a map I can revisit later. The frameworks will change, the syntax will evolve, but the way I learn, reflect, and connect the dots—that is what lasts.\n\nFrameworks change fast. Learning how you learn is the part that compounds.\n",
    "readingTime": 3
  },
  {
    "title": "Notes in Service of Doing: Choosing Inkdrop",
    "date": "2025-12-21T00:00:00.000Z",
    "description": "In this post, I want to share why I chose Inkdrop over tools like Obsidian and Notion—not because they fall short, but because of how I work as a solutions consultant and a part‑time web developer.",
    "tags": [
      "inkdrop",
      "note-taking",
      "developers",
      "productivity",
      "knowledge-management",
      "tools"
    ],
    "slug": "notes-in-service-of-doing-choosing-inkdrop",
    "topic": "inkdrop",
    "content": "\n## What is [Inkdrop](https://www.inkdrop.app/)?\n\nOn the surface, [Inkdrop](https://www.inkdrop.app/) is a note‑taking app for developers. You write in Markdown, you organize your thoughts, and you move on. But for me, it’s more than a notes app—it’s a deliberate constraint, and that’s exactly why it works.\n\n## Simple, Yet Powerful\n\nMost note‑taking apps I’ve tried are incredibly powerful. They come with endless features, deep customization, and thriving plugin ecosystems. Ironically, that power is also their biggest weakness—for me.\n\nWith so many knobs to turn and settings to tweak, I found myself spending more time _designing my note‑taking system_ than actually thinking or working. It became just another rabbit hole, layered on top of my split keyboard obsession and my ever‑evolving Neovim configuration. Another abstraction. Another system to maintain.\n\n[Inkdrop](https://www.inkdrop.app/) isn’t immune to this—you _can_ customize it—but its limits are clearly defined. And that’s what I love about it. The options are intentionally constrained, just enough to get you started quickly and focused on writing. Instead of spending five hours testing hundreds of plugins in search of a “perfect” setup that never really exists, I can sit down and start working through my thoughts.\n\n## When Ideas Become the Product\n\nOne of the most appealing features of modern note‑taking tools is the ability to connect ideas—to visualize them, link them, and grow a so‑called _second brain_. I get the appeal. I genuinely love ideas, and I love seeing how they relate to one another.\n\nBut I’ve also seen how easy it is to get lost in that process.\n\nI’ve watched countless tutorials where the focus shifts from thinking clearly to maintaining an elaborate web of connections. The visual becomes the goal, not the thinking behind it. Over time, the notes stop supporting the work and quietly _become the work_.\n\n## Execution Over Elegance\n\nAs a full‑time solutions consultant and part‑time developer, my job is not to build the most beautiful knowledge system imaginable. My job is to execute. Ideas matter—but they are a means, not the end.\n\nI’ve personally experienced how easy it is to become excellent at organizing notes while struggling to move ideas into reality. Time spent refining note architecture is time not spent designing real systems, solving real problems, or shipping real solutions.\n\nThis isn’t a criticism of Obsidian or Notion. They are fantastic tools, and for many people, they’re the right choice. For me, the deciding factor is cognitive overhead. [Inkdrop](https://www.inkdrop.app/) stays out of my way. It helps me think just enough—and then nudges me back to doing.\n\nAnd right now, that balance is exactly what I need.\n\n## The Community\n\nOne thing that surprised me most about [Inkdrop](https://www.inkdrop.app/) wasn’t the app itself, but the people around it.\n\nCompared to larger tools, the [Inkdrop](https://www.inkdrop.app/) community is small—and to me, that’s a feature, not a limitation. In the [Inkdrop Discord](https://my.inkdrop.app/login?redirect=/discord), the scale is just right: small enough that names feel familiar, conversations carry over from one day to the next, and people don’t disappear into noise.\n\nIt doesn’t feel like standing in a crowded room talking to strangers. It feels like a community.\n\nWhen you ask a question, you’re not shouting into the void. You get thoughtful responses, learn from others workflows, and sometimes just exchange ideas without the pressure to perform or optimize. There’s a sense of connection that’s hard to find in larger ecosystems.\n\nWhat surprised me even more is that while the space is centered around [Inkdrop](https://www.inkdrop.app/), the conversations often go far beyond it. You’ll see discussions about Neovim workflows, React patterns, or how to build [Inkdrop](https://www.inkdrop.app/) plugins—deep, thoughtful responses that are hard to come by in much larger Discord servers, where signal is often drowned out by scale.\n\nIn a space built around thinking clearly and working deliberately, this kind of human‑scale community feels like a natural extension of the tool itself.\n\n## Choosing to Commit\n\n[Inkdrop](https://www.inkdrop.app/) isn’t free. There’s a 30‑day trial—quiet, unhurried, and long enough to tell you whether this tool fits the way you think. By the time the month ends, you don’t need a spreadsheet to decide. You already know.\n\nBut trying [Inkdrop](https://www.inkdrop.app/) isn’t just about testing a product. It’s an invitation to slow the noise, to work with fewer knobs to turn, and to pay attention to what actually matters. If you decide to step in, don’t do it alone—join the conversation. Linger in the community. Ask questions. Listen.\n\nThat’s when the price reveals its real shape. Not as a fee, but as a commitment—to focus over friction, to execution over endless preparation, and to a small, thoughtful space where work gets done quietly and well.\n",
    "readingTime": 4
  },
  {
    "title": "macOS Neovim 0.11+ Native LSP Configuration",
    "date": "2025-12-20T00:00:00.000Z",
    "description": "Step by step guide on how to setup LSP in Neovim 0.11+ in macOS.",
    "tags": [
      "vim",
      "neovim",
      "lsp",
      "configuration"
    ],
    "slug": "native-lsp-setup-in-neovim-0.11+-on-macos",
    "topic": "neovim",
    "content": "\nNeovim 0.11 (released March 2025) introduced a simpler, fully native way to configure the Language Server Protocol (LSP). With this release, LSP becomes a true first-class citizen—no extra plugins required for basic setup.\n\nYou can still use Mason, a Neovim plugin that acts as a portable package manager for external development tooling such as LSP servers, DAP servers, linters, and formatters.\n\n> NOTE: Mason itself does not configure the LSP servers for use in Neovim. It just installs and manages the binaries/tools. To wire them up with Neovim built-in LSP client, you can use mason-lspconfig.nvim together with nvim-lspconfig.\n\nWhat we’ll cover today is a more manual approach. It requires installing LSP servers—such as lua-language-server—directly on your machine. This approach isn’t portable. You’ll need to reinstall the server when setting up a new machine, or automate it with a shell [script](https://github.com/rjleyva/dotfiles-macos/blob/main/scripts/dev-setup.sh).\n\nLet's begin with installing `lua-language-server` via homebrew:\n\n```bash\nbrew install lua-language-server\n```\n\n> NOTE: You can also install this via npm but I prefer to use homebrew for this instance.\n\n### Structure Overview\n\nThe structure is based on [Marco Peluso](https://www.youtube.com/watch?v=tdhxpn1XdjQ) YouTube video.\n\n```bash\nnvim/\n├── init.lua\n├── lsp/\n│   └── lua_ls.lua\n└── lua/\n    └── core/\n        └── lsp.lua\n```\n\n`lsp/` contains server specifications only, while `lua/core/` is responsible for enabling and orchestrating them. This keeps configuration declarative and avoids coupling server definitions to startup logic.\n\n### Step-by-Step Setup\n\nLet’s start by creating the `nvim` directory:\n\n```bash\nmkdir -p ~/.config/nvim\n```\n\nThen move to the `nvim` directory by running this command:\n\n```bash\ncd ~/.config/nvim\n```\n\nCreate the main `init.lua` file:\n\n```bash\nnvim init.lua\n```\n\nand add this configuration:\n\n```lua\nrequire('core.lsp')\n```\n\nNow let's create the `lsp` directory:\n\n```bash\nmkdir lsp\n```\n\nThen move to `lsp` directory by running this command:\n\n```bash\ncd lsp\n```\n\nCreate `lua_ls.lua` by running this command:\n\n```bash\nnvim lua_ls.lua\n```\n\nThen add this to `lua_ls.lua`:\n\n```lua\nlocal M = {}\n\nM.spec = {\n  cmd = {\n    'lua-language-server',\n  },\n\n  filetypes = {\n    'lua',\n  },\n\n  root_markers = {\n    '.git',\n    '.luacheckrc',\n    '.luarc.json',\n    '.luarc.jsonc',\n    '.stylua.toml',\n    'selene.toml',\n    'selene.yml',\n  },\n\n  settings = {\n    Lua = {\n      runtime = {\n        version = 'LuaJIT',\n      },\n      diagnostics = {\n        globals = { 'vim' },\n      },\n      hint = {\n        enable = true,\n        setType = true,\n        paramType = true,\n        -- paramName = 'All',\n        -- semicolon = 'All',\n        -- arrayIndex = 'All',\n        -- moduleName = 'All',\n      },\n      telemetry = {\n        enable = false,\n      },\n      workspace = {\n        checkThirdParty = false,\n        library = {},\n        -- Enable if you want:\n        -- Full API docs and completion for plugin development\n        -- Autocompletion for all vim.api.* functions\n        -- Uncomment the line below to index Neovim’s runtime and plugins:\n        -- library = vim.api.nvim_get_runtime_file(),\n      },\n    },\n  },\n\n  single_file_support = true,\n  autostart = false, -- manually enabled via vim.lsp.enable\n  log_level = vim.lsp.protocol.MessageType.Warning,\n}\n\nM.name = 'lua_ls'\n\nreturn M.spec\n```\n\n> NOTE: These markers define how a project root is detected. This becomes useful once you start managing multiple language servers consistently.\n\nGo back to `nvim` directory by running this command:\n\n```bash\ncd ~/.config/nvim\n```\n\nThen create `lua` and `core` directory:\n\n```bash\nmkdir -p lua/core/\n```\n\nThen move inside `core` directory:\n\n```bash\ncd lua/core/\n```\n\nand create `lsp.lua`:\n\n```bash\nnvim lsp.lua\n```\n\nThen enable it using `vim.lsp.enable` like this:\n\nThis explicitly enables the Lua language server by name:\n\n```lua\nvim.lsp.enable({\n  'lua_ls',\n})\n```\n\n> NOTE: `vim.lsp.enable()` is available starting in Neovim 0.11 and replaces the need for `nvim-lspconfig` in simple setups.\n> This approach works well for most setups, but more complex workflows may still benefit from `lspconfig` or Mason integrations.\n\nInside Neovim you can run:\n\n```\ncheckhealth lsp\n```\n\nand you'll see something like this:\n\n```\nvim.lsp: Active Clients ~\n- lua_ls (id: 1)\n  - Version: 3.15.0\n  - Root directory: ~/dotfiles-macos\n  - Command: { \"lua-language-server\" }\n  - Settings: {\n      Lua = {\n        diagnostics = {\n          globals = { \"vim\" }\n        },\n        hint = {\n          enable = true,\n          paramType = true,\n          setType = true\n        },\n        runtime = {\n          version = \"LuaJIT\"\n        },\n        telemetry = {\n          enable = false\n        },\n        workspace = {\n          checkThirdParty = false,\n          library = {}\n        }\n      }\n    }\n  - Attached buffers: 2, 3\n```\n\nThis output confirms that `lua_ls` is running successfully.\n\nThis setup is what I currently use daily in my Neovim workflow.\n\n### Why use native LSP in Neovim 0.11+?\n\nMy main reason for choosing this approach is simple: fewer plugins to maintain, faster startup times, and easier debugging. While manually configuring LSP takes a bit more effort, it taught me a lot about what’s actually happening behind the scenes. I’m in control of everything, and each configuration exists because I need it—not because a plugin decided for me.\n\n### Who is this for?\n\nThis setup is ideal if you:\n\n- Use Neovim 0.11+\n- Want fewer plugins and more control\n- Prefer understanding how LSP works under the hood\n\nIf you want a fully portable, zero-setup experience, Mason may still be a better fit.\n\nThis approach scales naturally as you add more language servers. In future posts, I’ll cover keymaps, diagnostics, formatting, and multi-server setups—still using Neovim’s native LSP.\n\nYou can find the full working Neovim configuration [here](https://github.com/rjleyva/dotfiles-macos).\n\n### Next steps\n\n- Add more language servers using the same `lsp/` pattern\n- Define LSP keymaps and diagnostics\n- Integrate formatting without external plugins\n\nSee you in the next post.\n",
    "readingTime": 5
  },
  {
    "title": "My WezTerm Terminal Setup",
    "date": "2025-12-05T00:00:00.000Z",
    "description": "How I tuned my terminal for long, focused coding sessions by reducing visual noise and prioritizing ergonomics.",
    "tags": [
      "wezterm",
      "terminal",
      "productivity",
      "setup"
    ],
    "slug": "wezterm-terminal-setup",
    "topic": "wezterm",
    "content": "\n# Finding Zen in My Terminal\n\nI spend most of my day in the terminal. At first, I didn’t notice the small UI\ndetails that quietly distracted me—tab bars, window chrome, slight background\nclutter. Over time, I realized these little things were adding noise and making\nlong coding sessions more tiring than they needed to be.\n\nThis is the story of how I stripped my terminal down to just what I need,\ncreating a setup that lets me focus for hours without friction.\n\n> This isn’t a “best practices” guide. It’s just what works for me.\n\n## Saying Goodbye to the Tab Bar\n\nOnce I leaned on TMUX for splits and layouts, the tab bar became redundant. I\nturned it off:\n\n```lua\nenable_tab_bar = false\n```\n\nIt was like decluttering my desk. Suddenly, there was nothing in my way but the\ntext.\n\n## Minimal but Practical\n\nI also wanted to keep the window frame minimal but practical. I don’t need full\nwindow chrome, just enough to resize the terminal when I need it:\n\n```lua\nwindow_decorations = \"RESIZE\"\n```\n\n## A Subtle Blur for Separation (macOS)\n\nOn macOS, I added a subtle blur behind the terminal. I experimented with\ntransparency and different blur levels until I landed on something gentle:\n\n```lua\nmacos_window_background_blur = 10\n```\n\nIt gives a slight separation from the desktop without making the text fuzzy—just\nenough breathing room to reduce eye fatigue.\n\n## Full Opacity for Comfort\n\nI used to play with transparency, but in the end, full opacity won. The text\nfeels more consistent and easier on the eyes:\n\n```lua\nwindow_background_opacity = 1.0\n```\n\n## Choosing a Font That Works\n\nFonts are surprisingly important. I went with Lilex Nerd Font because it’s\nreadable and has great glyph coverage. I also bumped the size up—comfort over\ncramming as many lines as possible:\n\n```lua\nfont = wezterm.font_with_fallback({ \"Lilex Nerd Font\" })\nfont_size = 18\n```\n\n## Scrollback That Actually Works\n\nScrollback is another small tweak that makes a big difference. A deeper buffer\nmeans I can review long logs or retrace commands without frustration:\n\n```lua\nscrollback_lines = 10000\n```\n\n## Colors That Don’t Tire Your Eyes\n\nFinally, colors. I use the solarized-osaka palette because it’s easy on the eyes\nfor long sessions. Nothing flashy, nothing harsh:\n\n```lua\ncolors = {\n  foreground = \"#839395\",\n  background = \"#001419\",\n\n  cursor_bg = \"#839395\",\n  cursor_border = \"#839395\",\n  cursor_fg = \"#001419\",\n\n  selection_bg = \"#1a6397\",\n  selection_fg = \"#839395\",\n\n  ansi = {\n    \"#001014\",\n    \"#db302d\",\n    \"#849900\",\n    \"#b28500\",\n    \"#268bd3\",\n    \"#d23681\",\n    \"#29a298\",\n    \"#9eabac\",\n  },\n\n  brights = {\n    \"#001419\",\n    \"#db302d\",\n    \"#849900\",\n    \"#b28500\",\n    \"#268bd3\",\n    \"#d23681\",\n    \"#29a298\",\n    \"#839395\",\n  },\n},\n```\n\n## The Full Zen Configuration\n\n```lua\nlocal wezterm = require(\"wezterm\")\n\nlocal M = {}\n\nM.spec = {\n  enable_tab_bar = false,\n  window_decorations = \"RESIZE\",\n  window_background_opacity = 1.0,\n  macos_window_background_blur = 10,\n  font = wezterm.font_with_fallback({ \"Lilex Nerd Font\" }),\n  font_size = 18,\n  scrollback_lines = 10000,\n\n  colors = {\n    foreground = \"#839395\",\n    background = \"#001419\",\n\n    cursor_bg = \"#839395\",\n    cursor_border = \"#839395\",\n    cursor_fg = \"#001419\",\n\n    selection_bg = \"#1a6397\",\n    selection_fg = \"#839395\",\n\n    ansi = {\n      \"#001014\",\n      \"#db302d\",\n      \"#849900\",\n      \"#b28500\",\n      \"#268bd3\",\n      \"#d23681\",\n      \"#29a298\",\n      \"#9eabac\",\n    },\n\n    brights = {\n      \"#001419\",\n      \"#db302d\",\n      \"#849900\",\n      \"#b28500\",\n      \"#268bd3\",\n      \"#d23681\",\n      \"#29a298\",\n      \"#839395\",\n    },\n  },\n}\n\nreturn M.spec\n```\n\nOver time, I realized that small adjustments—fonts, colors, scrollback, even\nsubtle blur—compound in impact. Each tweak reduces friction, letting the terminal\nfade into the background so I can focus on code.\n\nThis setup is my “zen mode.” It’s not perfect and it will probably evolve, but\nfor now, it transforms the terminal from a tool I wrestle with into a space I can\ninhabit for hours, fully immersed in work.\n",
    "readingTime": 3
  }
] as const
