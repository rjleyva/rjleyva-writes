import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'
import { parse as parseYaml } from 'yaml'
import type { Post, PostFrontmatter } from '@/types/post'

// Parsed frontmatter and content from markdown file
interface ParsedMarkdownFile {
  frontmatter: PostFrontmatter
  markdownBody: string
}

// Script configuration and paths
const SCRIPT_DIRECTORY = path.dirname(fileURLToPath(import.meta.url))
const BLOG_CONTENT_DIRECTORY = path.join(
  SCRIPT_DIRECTORY,
  '../src/content/blog'
)

const parseMarkdownFile = (rawFileContent: string): ParsedMarkdownFile => {
  const frontmatterPattern = /^---\n([\s\S]*?)\n---\n/
  const frontmatterMatch = rawFileContent.match(frontmatterPattern)

  let parsedFrontmatter: PostFrontmatter = {
    title: '',
    date: '',
    description: '',
    tags: []
  }

  let markdownContent = rawFileContent

  const frontmatterText = frontmatterMatch?.[1]
  if (frontmatterText != null && frontmatterText.trim() !== '') {
    try {
      parsedFrontmatter = parseYaml(frontmatterText) as PostFrontmatter
      markdownContent = rawFileContent.replace(frontmatterPattern, '')
    } catch {
      // Treat invlid YAML as plain markdown to avoid build failures
      console.warn(
        'Warning: Invalid YAML in frontmatter, treating as plain markdown'
      )
    }
  }

  return {
    frontmatter: parsedFrontmatter,
    markdownBody: markdownContent
  }
}

const discoverMarkdownFiles = (): string[] => {
  const discoveredFiles: string[] = []

  const scanDirectoryRecursively = (
    absoluteDirectoryPath: string,
    relativePathFromContentRoot = ''
  ): void => {
    const directoryEntries = fs.readdirSync(absoluteDirectoryPath, {
      withFileTypes: true
    })

    for (const entry of directoryEntries) {
      const fullEntryPath = path.join(absoluteDirectoryPath, entry.name)
      const relativeEntryPath = path.join(
        relativePathFromContentRoot,
        entry.name
      )

      if (entry.isDirectory()) {
        // Support topic based organization with nested directories
        scanDirectoryRecursively(fullEntryPath, relativeEntryPath)
      } else if (entry.isFile() && entry.name.endsWith('.md')) {
        discoveredFiles.push(relativeEntryPath)
      }
    }
  }

  scanDirectoryRecursively(BLOG_CONTENT_DIRECTORY)
  return discoveredFiles
}

const generateContentLoaderModule = (markdownFilePaths: string[]): string => {
  const importStatements: string[] = []
  const moduleMappings: string[] = []
  const processedBlogPosts: Post[] = []

  for (const relativeFilePath of markdownFilePaths) {
    const importVariableName =
      relativeFilePath.replace(/[^a-zA-Z0-9]/g, '_') + '_content'
    const viteImportPath = `@/content/blog/${relativeFilePath}?raw`

    importStatements.push(
      `import ${importVariableName} from '${viteImportPath}'`
    )

    moduleMappings.push(
      `  '@/content/blog/${relativeFilePath}': ${importVariableName}`
    )

    const absoluteFilePath = path.join(BLOG_CONTENT_DIRECTORY, relativeFilePath)
    const rawFileContent = fs.readFileSync(absoluteFilePath, 'utf-8')
    const parsedFile = parseMarkdownFile(rawFileContent)

    const pathSegments = relativeFilePath.split('/')
    const topicFromPath = pathSegments[pathSegments.length - 2] ?? ''
    const filename = pathSegments[pathSegments.length - 1] ?? ''
    const slugFromFilename = filename.replace('.md', '')

    // Use 200 words per minute for reading time calculation
    const wordCount = parsedFile.markdownBody.split(/\s+/).length
    const estimatedReadingTimeMinutes = Math.ceil(wordCount / 200)
    const blogPost: Post = {
      title: parsedFile.frontmatter.title,
      date:
        parsedFile.frontmatter.date instanceof Date
          ? parsedFile.frontmatter.date
          : new Date(parsedFile.frontmatter.date),
      description: parsedFile.frontmatter.description,
      tags: parsedFile.frontmatter.tags ?? [],
      slug: slugFromFilename,
      topic: topicFromPath,
      content: parsedFile.markdownBody,
      readingTime: estimatedReadingTimeMinutes
    }

    processedBlogPosts.push(blogPost)
  }

  const generatedModuleContent = `// Auto-generated content imports - do not edit manually
// Generated by scripts/generateContentImports.ts
// This file provides type-safe access to all blog content at build time

${importStatements.join('\n')}

// Raw markdown content accessible by file path
export const contentModules = {
${moduleMappings.join(',\n')}
}

// Processed blog posts with metadata and content
export const processedPosts = ${JSON.stringify(processedBlogPosts, null, 2)} as const
`

  return generatedModuleContent
}

const executeContentGeneration = (): void => {
  console.log('Discovering markdown files...')
  const discoveredMarkdownFiles = discoverMarkdownFiles()

  console.log('Processing content and generating TypeScript module...')
  const generatedContentModule = generateContentLoaderModule(
    discoveredMarkdownFiles
  )

  const outputFilePath = path.join(
    SCRIPT_DIRECTORY,
    '../src/lib/content/generatedContent.ts'
  )

  fs.writeFileSync(outputFilePath, generatedContentModule)

  console.log(
    `Generated content loader for ${discoveredMarkdownFiles.length} files`
  )
  discoveredMarkdownFiles.forEach(filePath => {
    console.log(`  ${filePath}`)
  })
}

executeContentGeneration()
